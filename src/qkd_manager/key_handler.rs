//! QKD manager key handler, supposed to run in a separate thread

use std::convert::identity;
use std::io;
use uuid::Bytes;
use x509_parser::nom::AsBytes;
use crate::{io_err, KmeId, qkd_manager, SaeClientCertSerial, SaeId};
use crate::qkd_manager::{http_request_obj, KMEInfo, PreInitQkdKeyWrapper, QkdManagerCommand, QkdManagerResponse, router, SAEInfo};
use base64::{engine::general_purpose, Engine as _};
use log::{error, info, warn};
use crate::qkd_manager::http_response_obj::{ResponseQkdKey, ResponseQkdKeysList};
use crate::ensure_prepared_statement_ok;

/// Describes the key handler that will check authentication and manage the QKD keys in the database in a separate thread
pub(super) struct KeyHandler {
    /// Channel to receive commands from the QKD manager (main thread)
    command_rx: crossbeam_channel::Receiver<QkdManagerCommand>,
    /// Channel to send responses to the QKD manager (main thread)
    response_tx: crossbeam_channel::Sender<QkdManagerResponse>,
    /// Connection to the sqlite database (in memory or on disk)
    sqlite_db: sqlite::Connection,
    /// The ID of this KME
    this_kme_id: KmeId,
    /// Router on classical network, used to connect to other KMEs over unsecure classical network
    qkd_router: router::QkdRouter,
}

impl KeyHandler {

    /// Create a new key handler
    /// # Arguments
    /// * `sqlite_db_path` - The path to the sqlite database file, or ":memory:" to use an in-memory database
    /// * `command_rx` - The channel to receive commands from the QKD manager (main thread)
    /// * `response_tx` - The channel to send responses to the QKD manager (main thread)
    /// # Returns
    /// A new key handler
    /// # Errors
    /// If the sqlite database cannot be opened or if the tables cannot be created
    pub(super) fn new(sqlite_db_path: &str, command_rx: crossbeam_channel::Receiver<QkdManagerCommand>, response_tx: crossbeam_channel::Sender<QkdManagerResponse>, this_kme_id: KmeId) -> Result<Self, io::Error> {
        const DATABASE_INIT_REQ: &'static str = include_str!("init_qkd_database.sql");

        let key_handler = Self {
            command_rx,
            response_tx,
            // Open the sqlite database
            sqlite_db: sqlite::open(sqlite_db_path).map_err(|e| {
                io::Error::new(io::ErrorKind::NotConnected, format!("Error opening sqlite database: {:?}", e))
            })?,
            this_kme_id,
            qkd_router: router::QkdRouter::new(),
        };
        // Create the tables if they do not exist
        key_handler.sqlite_db.execute(DATABASE_INIT_REQ).map_err(|e| {
            io::Error::new(io::ErrorKind::InvalidInput, format!("Error creating sqlite tables: {:?}", e))
        })?;
        Ok(key_handler)
    }

    /// Run the key handler, in a separate thread (infinite loop)
    /// # Note
    /// The calling SAE is authenticated by its certificate serial number, and designates the counterpart SAE by its SAE ID
    pub(super) fn run(&mut self) -> ! {
        // Infinite loop to receive commands and send responses
        loop {
            // Receive a command
            match self.command_rx.recv() {
                Ok(cmd) => {
                    match cmd {
                        // Insert a key into the database, each time a QKD exchange occurs
                        QkdManagerCommand::AddPreInitKey(key) => {
                            info!("Adding key for KME ID {} and {}", self.this_kme_id, key.other_kme_id);
                            if self.response_tx.send(self.add_preinit_qkd_key(key).unwrap_or_else(identity)).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        },
                        // The master SAE asks for keys ready to be sent to the slave SAE
                        QkdManagerCommand::GetKeys(sae_certificate_serial, slave_sae_id) => {
                            info!("Getting key for SAE ID {}", slave_sae_id);
                            if self.response_tx.send(self.get_sae_keys(&sae_certificate_serial, slave_sae_id).unwrap_or_else(identity)).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        }
                        // The slave SAE gets keys generated by the master SAE by their IDs
                        QkdManagerCommand::GetKeysWithIds(sae_certificate_serial, master_sae_id, keys_uuids) => {
                            info!("Getting keys from SAE ID {}", master_sae_id);
                            if self.response_tx.send(self.get_sae_keys_with_ids(&sae_certificate_serial, master_sae_id, keys_uuids).unwrap_or_else(identity)).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        },
                        // Add a new SAE ID to the database
                        QkdManagerCommand::AddSae(sae_id, kme_id, sae_certificate_serial) => {
                            info!("Adding SAE ID {}", sae_id);
                            if self.response_tx.send(self.add_sae(sae_id, kme_id, &sae_certificate_serial).unwrap_or_else(identity)).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        },
                        // Get keys status between origin SAE and target SAE
                        QkdManagerCommand::GetStatus(origin_sae_certificate, target_sae_id) => {
                            info!("Getting status for SAE ID {}", target_sae_id);
                            if self.response_tx.send(self.get_sae_status(&origin_sae_certificate, target_sae_id).unwrap_or_else(identity)).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        },
                        QkdManagerCommand::GetSaeInfoFromCertificate(sae_certificate) => {
                            info!("Getting SAE info from certificate");
                            let sae_info_response = self.get_sae_infos_from_certificate(&sae_certificate).unwrap_or_else(identity);
                            if self.response_tx.send(sae_info_response).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        },
                        QkdManagerCommand::GetKmeIdFromSaeId(sae_id) => {
                            let kme_id = self.get_kme_id_from_sae_id(sae_id);
                            let response = match kme_id {
                                Some(kme_id) => QkdManagerResponse::KmeInfo(KMEInfo {
                                    kme_id,
                                }),
                                None => {
                                    warn!("Get KME ID from SAE ID: SAE ID not found in database");
                                    QkdManagerResponse::NotFound
                                },
                            };
                            if self.response_tx.send(response).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        },
                        QkdManagerCommand::ActivateKeyFromRemote(origin_sae_id, target_sae_id, target_key_uuid) => {
                            let key_activate_response = self.activate_key_uuid_sae(origin_sae_id, target_sae_id, target_key_uuid).unwrap_or_else(identity);
                            if self.response_tx.send(key_activate_response).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        }
                        QkdManagerCommand::AddKmeClassicalNetInfo(kme_id, kme_addr_or_domain, conn_client_cert, conn_cert_password) => {
                            let add_kme_response = match self.qkd_router.add_kme_to_ip_domain_port_association(kme_id, &kme_addr_or_domain, &conn_client_cert, &conn_cert_password) {
                                Ok(_) => QkdManagerResponse::Ok,
                                Err(e) => {
                                    error!("Error adding KME classical network info: {:?}", e);
                                    QkdManagerResponse::Ko
                                },
                            };
                            if self.response_tx.send(add_kme_response).is_err() {
                                error!("Error QKD manager sending response");
                            }
                        }
                    }
                }
                Err(e) => {
                    error!("Error receiving command: {:?}", e);
                }
            }
        }
    }

    /// Add a new SAE ID to the database
    /// # Arguments
    /// * `sae_id` - The SAE ID to add
    /// * `kme_id` - The KME ID to associate with the SAE ID
    /// * `sae_certificate_serial` - The SAE certificate serial number, None if the SAE isn't supposed to authenticate to this KME
    fn add_sae(&self, sae_id: SaeId, kme_id: KmeId, sae_certificate_serial: &Option<SaeClientCertSerial>) -> Result<QkdManagerResponse, QkdManagerResponse> {
        const PREPARED_STATEMENT_KNOWN_CERT: &'static str = "INSERT INTO saes (sae_id, kme_id, sae_certificate_serial) VALUES (?, ?, ?);";
        const PREPARED_STATEMENT_NO_CERT: &'static str = "INSERT INTO saes (sae_id, kme_id) VALUES (?, ?);";

        let has_provided_certificate = sae_certificate_serial.is_some();
        let is_this_kme = kme_id == self.this_kme_id;
        // Has given certificate and doesn't belong to this KME, or doesn't have certificate and belongs to this KME
        if has_provided_certificate != is_this_kme {
            return Err(QkdManagerResponse::InconsistentSaeData);
        }

        let statement = match sae_certificate_serial {
            Some(_) => PREPARED_STATEMENT_KNOWN_CERT,
            None => PREPARED_STATEMENT_NO_CERT,
        };

        let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, statement);
        stmt.bind((1, sae_id)).map_err(|_| {
            QkdManagerResponse::Ko
        })?;
        stmt.bind((2, kme_id)).map_err(|_| {
            QkdManagerResponse::Ko
        })?;
        if sae_certificate_serial.is_some() {
            stmt.bind((3, sae_certificate_serial.unwrap().as_bytes())).map_err(|_| {
                QkdManagerResponse::Ko
            })?;
        }
        stmt.next().map_err(|_| {
            QkdManagerResponse::Ko
        })?;
        Ok(QkdManagerResponse::Ok)
    }

    fn add_preinit_qkd_key(&self, pre_init_key: PreInitQkdKeyWrapper) -> Result<QkdManagerResponse, QkdManagerResponse> {
        const PREPARED_STATEMENT: &'static str = "INSERT INTO uninit_keys (key_uuid, key, other_kme_id) VALUES (?, ?, ?);";

        let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, PREPARED_STATEMENT);
        let uuid_bytes = Bytes::try_from(pre_init_key.key_uuid).map_err(|_| {
            error!("Error converting UUID to bytes");
            QkdManagerResponse::Ko
        })?;
        let uuid_str = uuid::Uuid::from_bytes(uuid_bytes).to_string();
        stmt.bind((1, uuid_str.as_str())).map_err(|_| {
            QkdManagerResponse::Ko
        })?;
        stmt.bind((2, pre_init_key.key.as_bytes())).map_err(|_| {
            QkdManagerResponse::Ko
        })?;
        stmt.bind((3, pre_init_key.other_kme_id)).map_err(|_| {
            QkdManagerResponse::Ko
        })?;
        stmt.next().map_err(|_| {
            QkdManagerResponse::Ko
        })?;
        Ok(QkdManagerResponse::Ok)
    }

    fn get_sae_status(&self, origin_sae_certificate: &SaeClientCertSerial, target_sae_id: SaeId) -> Result<QkdManagerResponse, QkdManagerResponse> {
        const PREPARED_STATEMENT: &'static str = "SELECT COUNT(*) FROM uninit_keys WHERE other_kme_id = ?;";

        let target_kme_id = self.get_kme_id_from_sae_id(target_sae_id).ok_or(QkdManagerResponse::NotFound)?;

        // Ensure the origin (master) SAE ID is valid, and get its SAE id
        let origin_sae_id = self.get_sae_id_from_certificate(origin_sae_certificate).ok_or(QkdManagerResponse::AuthenticationError)?;

        let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, PREPARED_STATEMENT);
        stmt.bind((1, target_kme_id)).map_err(|_| {
            error!("Error binding target SAE ID");
            QkdManagerResponse::Ko
        })?;
        stmt.next().map_err(|_| {
            error!("Error executing SQL statement");
            QkdManagerResponse::Ko
        })?;
        let key_count: i64 = stmt.read::<i64, usize>(0).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;

        let source_kme_id = self.this_kme_id; // This KME

        // Create key exchange status response object
        let response_qkd_key_status = qkd_manager::http_response_obj::ResponseQkdKeysStatus {
            source_KME_ID: source_kme_id.to_string(),
            target_KME_ID: target_kme_id.to_string(),
            master_SAE_ID: origin_sae_id.to_string(),
            slave_SAE_ID: target_sae_id.to_string(),
            key_size: crate::QKD_KEY_SIZE_BITS,
            stored_key_count: key_count as usize,
            max_key_count: crate::MAX_QKD_KEYS_PER_SAE,
            max_key_per_request: crate::MAX_QKD_KEYS_PER_REQUEST,
            max_key_size: crate::QKD_MAX_KEY_SIZE_BITS,
            min_key_size: crate::QKD_MIN_KEY_SIZE_BITS,
            max_SAE_ID_count: crate::MAX_QKD_KEY_SAE_IDS,
        };

        Ok(QkdManagerResponse::Status(response_qkd_key_status))
    }

    fn get_sae_keys(&self, origin_sae_certificate: &SaeClientCertSerial, target_sae_id: SaeId) -> Result<QkdManagerResponse, QkdManagerResponse> {
        const FETCH_PREINIT_KEY_PREPARED_STATEMENT: &'static str = "SELECT id, key_uuid, key, other_kme_id FROM uninit_keys WHERE other_kme_id = ? LIMIT 1;";

        // Ensure the origin (master) SAE ID is valid, and get its SAE id
        let origin_sae_id = self.get_sae_id_from_certificate(origin_sae_certificate).ok_or(QkdManagerResponse::AuthenticationError)?;
        let origin_kme_id = self.this_kme_id;
        let target_kme_id = self.get_kme_id_from_sae_id(target_sae_id).ok_or(QkdManagerResponse::NotFound)?;

        let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, FETCH_PREINIT_KEY_PREPARED_STATEMENT);
        stmt.bind((1, target_kme_id)).map_err(|_| {
            error!("Error binding target KME ID");
            QkdManagerResponse::Ko
        })?;
        let sql_execution_state = stmt.next().map_err(|_| {
            error!("Error executing SQL statement");
            QkdManagerResponse::Ko
        })?;

        if sql_execution_state != sqlite::State::Row {
            return Err(QkdManagerResponse::NotFound); // TODO: we could return an empty array instead
        }

        let id = stmt.read::<i64, usize>(0).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;
        let key_uuid: String = stmt.read::<String, usize>(1).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;
        let key: Vec<u8> = stmt.read::<Vec<u8>, usize>(2).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;
        if origin_kme_id != target_kme_id {
            // send key to other KME
            // We must ensure:
            // - other KME is authenticated (client certificate and operating system trust store)
            // - other SAE belongs to other KME (statically managed for now)
            self.activate_key_on_other_kme(origin_sae_id, target_kme_id, target_sae_id, &key_uuid).map_err(|qkd_manager_activation_error| {
                error!("Error activating key on other KME");
                qkd_manager_activation_error
            })?;
        }

        self.delete_pre_init_key_with_id(id).map_err(|_| {
            error!("Error deleting pre-init key {}", id);
            QkdManagerResponse::Ko
        })?;

        info!("Saving key {} in init keys", key_uuid);

        self.insert_activated_key(&key_uuid, &key, origin_sae_id, target_sae_id).map_err(|_| {
            error!("Error inserting activated key");
            QkdManagerResponse::Ko
        })?;

        // Encode the key in base64
        let response_qkd_key = ResponseQkdKey {
            key_ID: key_uuid,
            key: general_purpose::STANDARD.encode(&key)
        };

        // Return a list of key objects
        Ok(QkdManagerResponse::Keys(ResponseQkdKeysList {
            keys: vec![response_qkd_key],
        }))
    }

    fn activate_key_uuid_sae(&self, origin_sae_id: SaeId, target_sae_id: SaeId, key_uuid: String) -> Result<QkdManagerResponse, QkdManagerResponse> {
        const GET_PRE_INIT_KEY_PREPARED_STATEMENT: &'static str = "SELECT id, key, other_kme_id FROM uninit_keys WHERE key_uuid = ? LIMIT 1;";

        let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, GET_PRE_INIT_KEY_PREPARED_STATEMENT);
        stmt.bind((1, key_uuid.as_str())).map_err(|_| {
            error!("Error binding key UUID");
            QkdManagerResponse::Ko
        })?;
        let sql_execution_state = stmt.next().map_err(|_| {
            error!("Error executing SQL statement");
            QkdManagerResponse::Ko
        })?;

        if sql_execution_state != sqlite::State::Row {
            return Err(QkdManagerResponse::NotFound);
        }

        let key_id = stmt.read::<i64, usize>(0).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;
        let key: Vec<u8> = stmt.read::<Vec<u8>, usize>(1).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;
        let _other_kme_id = stmt.read::<KmeId, usize>(2).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;

        self.insert_activated_key(&key_uuid, &key, origin_sae_id, target_sae_id).map_err(|_| {
            error!("Error inserting activated key");
            QkdManagerResponse::Ko
        })?;
        self.delete_pre_init_key_with_id(key_id).map_err(|_| {
            error!("Error deleting pre-init key {}", key_id);
            QkdManagerResponse::Ko
        })?;

        info!("Key {} activated between saes {} and {}", key_uuid, origin_sae_id, target_sae_id);
        Ok(QkdManagerResponse::Ok)
    }

    fn activate_key_on_other_kme(&self, caller_master_sae_id: SaeId, other_kme_id: KmeId, other_sae_id: SaeId, key_uuid: &str) -> Result<(), QkdManagerResponse> {
        let danger_should_ignore_remote_kme_cert = match std::env::var(crate::DANGER_IGNORE_CERTS_INTER_KME_NETWORK_ENV_VARIABLE) {
            Ok(val) => val == crate::ACTIVATED_ENV_VARIABLE_VALUE,
            Err(_) => false,
        };

        let req_body = http_request_obj::ActivateKeyRemoteKME {
            key_ID: key_uuid.to_string(),
            origin_SAE_ID: caller_master_sae_id,
            remote_SAE_ID: other_sae_id,
        };
        let kme_classical_info = match self.qkd_router.get_classical_connection_info_from_kme_id(other_kme_id) {
            Some(info) => info,
            None => {
                error!("KME ID not found");
                return Err(QkdManagerResponse::MissingRemoteKmeConfiguration);
            },
        };

        let kme_client_builer = reqwest::blocking::Client::builder().identity(kme_classical_info.tls_client_cert_identity.clone());

        let kme_client = if danger_should_ignore_remote_kme_cert {
            kme_client_builer.danger_accept_invalid_certs(true)
        } else {
            kme_client_builer
        }.build()
            .map_err(|_| {
                error!("Error building reqwest client");
                QkdManagerResponse::Ko
            })?;

        let response = kme_client.post(&format!("https://{}/keys/activate", kme_classical_info.ip_domain_port))
            .json(&req_body)
            .send()
            .map_err(|_| {
                error!("Error sending HTTP request");
                QkdManagerResponse::RemoteKmeCommunicationError
            })?;

        if response.status() != reqwest::StatusCode::OK {
            error!("Error activating key on other KME");
            return Err(QkdManagerResponse::RemoteKmeAcceptError);
        }

        Ok(())
    }

    fn insert_activated_key(&self, key_uuid: &str, key: &[u8], origin_sae_id: SaeId, target_sae_id: SaeId)-> Result<QkdManagerResponse, QkdManagerResponse> {
        const INSERT_INIT_KEY_PREPARED_STATEMENT: &'static str = "INSERT INTO keys (key_uuid, key, origin_sae_id, target_sae_id) VALUES (?, ?, ?, ?);";

        let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, INSERT_INIT_KEY_PREPARED_STATEMENT);
        stmt.bind((1, key_uuid)).map_err(|_| {
            error!("Error binding key UUID");
            QkdManagerResponse::Ko
        })?;
        stmt.bind((2, key)).map_err(|_| {
            error!("Error binding key");
            QkdManagerResponse::Ko
        })?;
        stmt.bind((3, origin_sae_id)).map_err(|_| {
            error!("Error binding origin SAE ID");
            QkdManagerResponse::Ko
        })?;
        stmt.bind((4, target_sae_id)).map_err(|_| {
            error!("Error binding target SAE ID");
            QkdManagerResponse::Ko
        })?;
        stmt.next().map_err(|_| {
            error!("Error executing SQL statement");
            QkdManagerResponse::Ko
        })?;
        Ok(QkdManagerResponse::Ok)
    }

    /// Delete a pre-init key from the pre-init keys database
    /// Called when master SAE requested the key: it becomes an init key
    /// So that the same key isn't requested again by a master SAE
    /// # Arguments
    /// * `key_id` - The ID of the pre init key to delete
    /// # Returns
    /// Ok if the key was deleted, an error otherwise
    fn delete_pre_init_key_with_id(&self, key_id: i64) -> Result<(), io::Error> {
        const PREPARED_STATEMENT: &'static str = "DELETE FROM uninit_keys WHERE id = ?;";

        let mut stmt = match self.sqlite_db.prepare(PREPARED_STATEMENT) {
            Ok(stmt) => stmt,
            Err(_) => {
                return Err(io_err("Error preparing SQL statement"));
            }
        };
        stmt.bind((1, key_id)).map_err(|_| {
            io_err("Error binding key ID")
        })?;
        stmt.next().map_err(|_| {
            io_err("Error executing SQL statement, maybe key ID not found in pre init keys database?")
        })?;
        Ok(())
    }

    fn get_sae_keys_with_ids(&self, current_sae_certificate: &SaeClientCertSerial, origin_sae_id: SaeId, keys_uuids: Vec<String>) -> Result<QkdManagerResponse, QkdManagerResponse> {
        const PREPARED_STATEMENT: &'static str = "SELECT key_uuid, key FROM keys WHERE target_sae_id = ? AND origin_sae_id = ? AND key_uuid = ? LIMIT 1;";

        // Ensure the caller (slave) SAE ID is valid and authenticated, and get its SAE id
        let current_sae_id = self.get_sae_id_from_certificate(current_sae_certificate).ok_or(QkdManagerResponse::AuthenticationError)?;

        // For each key UUID, retrieve the key from the database if it exists and is applicable to the caller SAE ID
        let keys = keys_uuids.iter().map(|key_uuid| {
            let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, PREPARED_STATEMENT);
            stmt.bind((1, current_sae_id)).map_err(|_| {
                error!("Error binding current SAE ID");
                QkdManagerResponse::Ko
            })?;
            stmt.bind((2, origin_sae_id)).map_err(|_| {
                error!("Error binding origin SAE ID");
                QkdManagerResponse::Ko
            })?;
            stmt.bind((3, key_uuid.as_str())).map_err(|_| {
                error!("Error binding key UUID");
                QkdManagerResponse::Ko
            })?;

            let sql_execution_state = stmt.next().map_err(|_| {
                error!("Error executing SQL statement");
                QkdManagerResponse::Ko
            })?;

            // Only 1 key should be returned by UUID
            if sql_execution_state != sqlite::State::Row {
                return Err(QkdManagerResponse::NotFound);
            }
            let key_uuid: String = stmt.read::<String, usize>(0).map_err(|_| {
                error!("Error reading SQL statement result");
                QkdManagerResponse::Ko
            })?;
            let key: Vec<u8> = stmt.read::<Vec<u8>, usize>(1).map_err(|_| {
                error!("Error reading SQL statement result");
                QkdManagerResponse::Ko
            })?;

            // Encode the key in base64
            Ok(ResponseQkdKey {
                key_ID: key_uuid,
                key: general_purpose::STANDARD.encode(&key),
            })
        }).collect::<Result<Vec<ResponseQkdKey>, QkdManagerResponse>>()?; // Generate a list of keys from all the results in database

        // Return a list of key objects
        Ok(QkdManagerResponse::Keys(ResponseQkdKeysList {
            keys,
        }))
    }

    /// Get the SAE ID from associated client certificate serial number
    /// # Arguments
    /// * `sae_certificate` - The client certificate serial number
    /// # Returns
    /// The SAE ID if the certificate serial number is found in the database, None otherwise
    fn get_sae_id_from_certificate(&self, sae_certificate: &SaeClientCertSerial) -> Option<SaeId> {
        const PREPARED_STATEMENT: &'static str = "SELECT sae_id FROM saes WHERE sae_certificate_serial = ? LIMIT 1;";
        let mut stmt = match self.sqlite_db.prepare(PREPARED_STATEMENT) {
            Ok(stmt) => stmt,
            Err(_) => {
                error!("Error preparing SQL statement");
                return None;
            }
        };
        stmt.bind((1, sae_certificate.as_bytes())).map_err(|_| {
            error!("Error binding SAE certificate serial");
            ()
        }).ok();
        let sql_execution_state = stmt.next().map_err(|_| {
            error!("Error executing SQL statement");
            ()
        }).ok()?;
        if sql_execution_state != sqlite::State::Row {
            info!("SAE certificate not found in database");
            return None;
        }
        let sae_id: SaeId = stmt.read::<SaeId, usize>(0).map_err(|_| {
            error!("Error reading SQL statement result");
            ()
        }).ok()?;
        Some(sae_id)
    }

    /// Get the KME ID from associated SAE ID
    /// # Arguments
    /// * `sae_id` - The SAE ID
    /// # Returns
    /// The KME ID if the SAE ID is found in the database, None otherwise
    fn get_kme_id_from_sae_id(&self, sae_id: SaeId) -> Option<KmeId> {
        const PREPARED_STATEMENT: &'static str = "SELECT kme_id FROM saes WHERE sae_id = ? LIMIT 1;";
        let mut stmt = match self.sqlite_db.prepare(PREPARED_STATEMENT) {
            Ok(stmt) => stmt,
            Err(_) => {
                error!("Error preparing SQL statement");
                return None;
            }
        };
        stmt.bind((1, sae_id)).map_err(|_| {
            error!("Error binding SAE ID");
            ()
        }).ok()?;
        let sql_execution_state = stmt.next().map_err(|_| {
            error!("Error executing SQL statement");
            ()
        }).ok()?;
        if sql_execution_state != sqlite::State::Row {
            info!("SAE ID not found in database");
            return None;
        }
        let kme_id: KmeId = stmt.read::<KmeId, usize>(0).map_err(|_| {
            error!("Error reading SQL statement result");
            ()
        }).ok()?;
        Some(kme_id)
    }

    /// Directly fetch SAE info from the certificate serial number, including the SAE ID and KME ID
    /// # Arguments
    /// * `sae_certificate` - The client SAE certificate serial number
    /// # Returns
    /// The SAE info, including KME ID, if the certificate serial number is found in the database, an error otherwise
    fn get_sae_infos_from_certificate(&self, sae_certificate: &SaeClientCertSerial) -> Result<QkdManagerResponse, QkdManagerResponse> {
        const PREPARED_STATEMENT: &'static str = "SELECT sae_id, kme_id FROM saes WHERE sae_certificate_serial = ? LIMIT 1;";
        let mut stmt = ensure_prepared_statement_ok!(self.sqlite_db, PREPARED_STATEMENT);
        stmt.bind((1, sae_certificate.as_bytes())).map_err(|_| {
            error!("Error binding SAE certificate serial");
            QkdManagerResponse::Ko
        })?;
        let sql_execution_state = stmt.next().map_err(|_| {
            error!("Error executing SQL statement");
            QkdManagerResponse::Ko
        })?;
        if sql_execution_state != sqlite::State::Row {
            return Err(QkdManagerResponse::NotFound);
        }
        let sae_id: SaeId = stmt.read::<SaeId, usize>(0).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;
        let kme_id: KmeId = stmt.read::<KmeId, usize>(1).map_err(|_| {
            error!("Error reading SQL statement result");
            QkdManagerResponse::Ko
        })?;
        Ok(QkdManagerResponse::SaeInfo(SAEInfo {
            sae_id,
            kme_id,
            sae_certificate_serial: *sae_certificate,
        }))
    }
}

/// Check SQL statement preparation and return the statement
#[macro_export]
macro_rules! ensure_prepared_statement_ok {
    ($sqlite_connection:expr, $statement:expr) => {
        match $sqlite_connection.prepare($statement) {
            Ok(stmt) => stmt,
            Err(_) => {
                error!("Error preparing SQL statement");
                return Err(QkdManagerResponse::Ko);
            }
        }
    }
}


#[cfg(test)]
mod tests {
    use std::thread;
    use crate::qkd_manager::http_response_obj::HttpResponseBody;
    use crate::qkd_manager::QkdManagerResponse;

    #[test]
    fn test_get_sae_id_from_certificate() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let sae_id = 1;
        let kme_id = 1;
        let sae_certificate_serial = [0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        key_handler.add_sae(sae_id, kme_id, &Some(sae_certificate_serial)).unwrap();
        assert_eq!(key_handler.get_sae_id_from_certificate(&sae_certificate_serial).unwrap(), sae_id);

        let fake_sae_certificate_serial = [1u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        assert_eq!(key_handler.get_sae_id_from_certificate(&fake_sae_certificate_serial), None);
    }

    #[test]
    fn test_add_preinit_key() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 1,
            key_uuid: *uuid::Uuid::from_bytes([0u8; 16]).as_bytes(),
            key: [0u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        key_handler.add_preinit_qkd_key(key).unwrap();
    }

    #[test]
    fn test_get_sae_status() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let sae_id = 1;
        let sae_certificate_serial = [0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        key_handler.add_sae(sae_id, 1, &Some(sae_certificate_serial)).unwrap();
        let qkd_manager_response = key_handler.get_sae_status(&sae_certificate_serial, sae_id).unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Status(_)));
        let response_status = match qkd_manager_response {
            QkdManagerResponse::Status(status) => status,
            _ => {
                panic!("Unexpected response");
            }
        };
        assert_eq!(response_status.to_json().unwrap(), "{\n  \"source_KME_ID\": \"1\",\n  \"target_KME_ID\": \"1\",\n  \"master_SAE_ID\": \"1\",\n  \"slave_SAE_ID\": \"1\",\n  \"key_size\": 256,\n  \"stored_key_count\": 0,\n  \"max_key_count\": 10,\n  \"max_key_per_request\": 1,\n  \"max_key_size\": 256,\n  \"min_key_size\": 256,\n  \"max_SAE_ID_count\": 0\n}");


        // add key for another KME id
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 2,
            key_uuid: *uuid::Uuid::from_bytes([0u8; 16]).as_bytes(),
            key: [0u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        key_handler.add_preinit_qkd_key(key).unwrap();
        let qkd_manager_response = key_handler.get_sae_status(&sae_certificate_serial, 2);
        assert!(matches!(qkd_manager_response, Err(QkdManagerResponse::NotFound)));

        key_handler.add_sae(2, 1, &Some([1u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES])).unwrap();
        let qkd_manager_response = key_handler.get_sae_status(&sae_certificate_serial, 2).unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Status(_)));
        let response_status = match qkd_manager_response {
            QkdManagerResponse::Status(status) => status,
            _ => {
                panic!("Unexpected response");
            }
        };
        assert_eq!(response_status.to_json().unwrap(), "{\n  \"source_KME_ID\": \"1\",\n  \"target_KME_ID\": \"1\",\n  \"master_SAE_ID\": \"1\",\n  \"slave_SAE_ID\": \"2\",\n  \"key_size\": 256,\n  \"stored_key_count\": 0,\n  \"max_key_count\": 10,\n  \"max_key_per_request\": 1,\n  \"max_key_size\": 256,\n  \"min_key_size\": 256,\n  \"max_SAE_ID_count\": 0\n}");

        // add key
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 1,
            key_uuid: *uuid::Uuid::from_bytes([0u8; 16]).as_bytes(),
            key: [0u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        key_handler.add_preinit_qkd_key(key).unwrap();
        let qkd_manager_response = key_handler.get_sae_status(&sae_certificate_serial, 2).unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Status(_)));
        let response_status = match qkd_manager_response {
            QkdManagerResponse::Status(status) => status,
            _ => {
                panic!("Unexpected response");
            }
        };
        assert_eq!(response_status.to_json().unwrap(), "{\n  \"source_KME_ID\": \"1\",\n  \"target_KME_ID\": \"1\",\n  \"master_SAE_ID\": \"1\",\n  \"slave_SAE_ID\": \"2\",\n  \"key_size\": 256,\n  \"stored_key_count\": 1,\n  \"max_key_count\": 10,\n  \"max_key_per_request\": 1,\n  \"max_key_size\": 256,\n  \"min_key_size\": 256,\n  \"max_SAE_ID_count\": 0\n}");
    }

    #[test]
    fn test_get_sae_keys() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let sae_id = 1;
        let kme_id = 1;
        let sae_certificate_serial = [0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        key_handler.add_sae(sae_id, kme_id, &Some(sae_certificate_serial)).unwrap();
        let qkd_manager_response = key_handler.get_sae_keys(&sae_certificate_serial, sae_id);
        assert!(matches!(qkd_manager_response, Err(QkdManagerResponse::NotFound)));

        // add key
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 1,
            key_uuid: *uuid::Uuid::from_bytes([0u8; 16]).as_bytes(),
            key: [0u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        key_handler.add_preinit_qkd_key(key).unwrap();

        // add key
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 1,
            key_uuid: *uuid::Uuid::from_bytes([1u8; 16]).as_bytes(),
            key: [1u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        key_handler.add_preinit_qkd_key(key).unwrap();

        let qkd_manager_response = key_handler.get_sae_keys(&sae_certificate_serial, 2);
        assert!(matches!(qkd_manager_response, Err(QkdManagerResponse::NotFound)));

        key_handler.add_sae(2, kme_id, &Some([1u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES])).unwrap();
        let qkd_manager_response = key_handler.get_sae_keys(&sae_certificate_serial, 2).unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Keys(_)));
        let response_keys = match qkd_manager_response {
            QkdManagerResponse::Keys(keys) => keys,
            _ => {
                panic!("Unexpected response");
            }
        };
        assert_eq!(response_keys.keys.len(), 1);
        assert_eq!(response_keys.keys[0].key_ID, "00000000-0000-0000-0000-000000000000");
        assert_eq!(response_keys.keys[0].key, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=");
        assert_eq!(response_keys.to_json().unwrap(), "{\n  \"keys\": [\n    {\n      \"key_ID\": \"00000000-0000-0000-0000-000000000000\",\n      \"key\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\n    }\n  ]\n}");


        // Same request
        let qkd_manager_response = key_handler.get_sae_keys(&sae_certificate_serial, 2).unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Keys(_)));
        let response_keys = match qkd_manager_response {
            QkdManagerResponse::Keys(keys) => keys,
            _ => {
                panic!("Unexpected response");
            }
        };
        assert_eq!(response_keys.keys.len(), 1);
        // Not the same key
        assert_eq!(response_keys.keys[0].key_ID, "01010101-0101-0101-0101-010101010101");
        assert_eq!(response_keys.keys[0].key, "AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE=");
        assert_eq!(response_keys.to_json().unwrap(), "{\n  \"keys\": [\n    {\n      \"key_ID\": \"01010101-0101-0101-0101-010101010101\",\n      \"key\": \"AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE=\"\n    }\n  ]\n}");
    }

    #[test]
    fn test_get_sae_keys_with_ids() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let sae_id = 1;
        let kme_id = 1;
        let sae_1_certificate_serial = [0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        let sae_2_certificate_serial = [1u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        key_handler.add_sae(sae_id, kme_id, &Some(sae_1_certificate_serial)).unwrap();
        key_handler.add_sae(2, kme_id, &Some(sae_2_certificate_serial)).unwrap();
        let qkd_manager_response = key_handler.get_sae_keys_with_ids(&sae_1_certificate_serial, sae_id, vec!["00000000-0000-0000-0000-000000000000".to_string()]);
        assert!(matches!(qkd_manager_response, Err(QkdManagerResponse::NotFound)));

        // add key
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 1,
            key_uuid: *uuid::Uuid::from_bytes([0u8; 16]).as_bytes(),
            key: [0u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        key_handler.add_preinit_qkd_key(key).unwrap();

        // SAE1 has to pre fetch the key first
        let qkd_manager_response = key_handler.get_sae_keys_with_ids(&sae_2_certificate_serial, 1, vec!["00000000-0000-0000-0000-000000000000".to_string()]);
        assert!(matches!(qkd_manager_response, Err(QkdManagerResponse::NotFound)));

        assert!(matches!(key_handler.get_sae_keys(&sae_1_certificate_serial, 2).unwrap(), QkdManagerResponse::Keys(_)));
        let qkd_manager_response = key_handler.get_sae_keys_with_ids(&sae_2_certificate_serial, 1, vec!["00000000-0000-0000-0000-000000000000".to_string()]).unwrap();

        assert!(matches!(qkd_manager_response, QkdManagerResponse::Keys(_)));
        let response_keys = match qkd_manager_response {
            QkdManagerResponse::Keys(keys) => keys,
            _ => {
                panic!("Unexpected response");
            }
        };
        assert_eq!(response_keys.keys.len(), 1);
        assert_eq!(response_keys.keys[0].key_ID, "00000000-0000-0000-0000-000000000000");
        assert_eq!(response_keys.keys[0].key, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=");

        // Revert origin and target SAE IDs
        let qkd_manager_response = key_handler.get_sae_keys_with_ids(&sae_1_certificate_serial, 2, vec!["00000000-0000-0000-0000-000000000000".to_string()]);
        assert!(matches!(qkd_manager_response, Err(QkdManagerResponse::NotFound)));
    }

    #[test]
    fn test_get_kme_id_from_sae() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let sae_id = 1;
        let kme_id = 1;
        let sae_1_certificate_serial = [0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        key_handler.add_sae(sae_id, kme_id, &Some(sae_1_certificate_serial)).unwrap();
        let kme_id = key_handler.get_kme_id_from_sae_id(sae_id).unwrap();
        assert_eq!(kme_id, 1);
        let kme_id = key_handler.get_kme_id_from_sae_id(2);
        assert!(matches!(kme_id, None));
    }

    #[test]
    fn test_get_sae_infos_from_certificate() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let sae_id = 1;
        let kme_id = 1;

        let sae_info = key_handler.get_sae_infos_from_certificate(&[0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES]);
        assert!(matches!(sae_info, Err(QkdManagerResponse::NotFound)));

        key_handler.add_sae(sae_id, kme_id, &Some([0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES])).unwrap();
        let sae_info = key_handler.get_sae_infos_from_certificate(&[0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES]).unwrap();
        assert!(matches!(sae_info, QkdManagerResponse::SaeInfo(_)));
        assert_eq!(sae_info, QkdManagerResponse::SaeInfo(super::SAEInfo {
            sae_id,
            kme_id,
            sae_certificate_serial: [0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES],
        }));
    }

    #[test]
    fn test_delete_pre_init_key_with_id() {
        let (_, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, _) = crossbeam_channel::unbounded();
        let key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 1,
            key_uuid: *uuid::Uuid::from_bytes([0u8; 16]).as_bytes(),
            key: [0u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        key_handler.add_preinit_qkd_key(key).unwrap();
        let key_id = 1; // As it's the first key, we can assume it's the ID
        key_handler.delete_pre_init_key_with_id(key_id).unwrap();
    }

    #[test]
    fn test_run() {
        let (command_tx, command_channel_rx) = crossbeam_channel::unbounded();
        let (response_channel_tx, response_rx) = crossbeam_channel::unbounded();
        let mut key_handler = super::KeyHandler::new(":memory:", command_channel_rx, response_channel_tx, 1).unwrap();
        let sae_id = 1;
        let kme_id = 1;
        let sae_certificate_serial = [0u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES];
        let _ = thread::spawn(move || {
            key_handler.run();
        });
        command_tx.send(super::QkdManagerCommand::AddSae(sae_id, kme_id, Some(sae_certificate_serial))).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Ok));

        command_tx.send(super::QkdManagerCommand::GetKeys(sae_certificate_serial, sae_id)).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::NotFound));

        // add key
        let key = crate::qkd_manager::PreInitQkdKeyWrapper {
            other_kme_id: 1,
            key_uuid: *uuid::Uuid::from_bytes([0u8; 16]).as_bytes(),
            key: [0u8; crate::QKD_KEY_SIZE_BITS / 8],
        };
        command_tx.send(super::QkdManagerCommand::AddPreInitKey(key)).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Ok));

        command_tx.send(super::QkdManagerCommand::GetKeysWithIds(sae_certificate_serial, 1, vec!["00000000-0000-0000-0000-000000000000".to_string()])).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::NotFound));

        command_tx.send(super::QkdManagerCommand::GetStatus(sae_certificate_serial, 2)).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::NotFound));

        command_tx.send(super::QkdManagerCommand::AddSae(2, kme_id, Some([1u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES]))).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Ok));

        command_tx.send(super::QkdManagerCommand::GetStatus(sae_certificate_serial, 2)).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Status(_)));

        command_tx.send(super::QkdManagerCommand::GetSaeInfoFromCertificate(sae_certificate_serial)).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::SaeInfo(_)));
        assert_eq!(qkd_manager_response, QkdManagerResponse::SaeInfo(super::SAEInfo {
            sae_id,
            kme_id,
            sae_certificate_serial,
        }));

        command_tx.send(super::QkdManagerCommand::GetSaeInfoFromCertificate([2u8; crate::CLIENT_CERT_SERIAL_SIZE_BYTES])).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::NotFound));

        command_tx.send(super::QkdManagerCommand::GetKmeIdFromSaeId(sae_id)).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::KmeInfo(_)));
        assert_eq!(qkd_manager_response, QkdManagerResponse::KmeInfo(super::KMEInfo {
            kme_id,
        }));
        command_tx.send(super::QkdManagerCommand::GetKmeIdFromSaeId(3)).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::NotFound));

        command_tx.send(super::QkdManagerCommand::AddKmeClassicalNetInfo(kme_id,
                                                                         String::from("wrong_data"),
                                                                         String::from("wrong_data"),
                                                                         String::from("wrong_data"))).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Ko));
        command_tx.send(super::QkdManagerCommand::AddKmeClassicalNetInfo(kme_id,
                                                                         String::from("test.fr:1234"),
                                                                         String::from("certs/inter_kmes/client-kme1-to-kme2.pfx"),
                                                                         String::from(""))).unwrap();
        let qkd_manager_response = response_rx.recv().unwrap();
        assert!(matches!(qkd_manager_response, QkdManagerResponse::Ok));
    }
}